generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DIRECT_DATABASE_URL")
}

model User {
  id                      String         @id @default(cuid())
  email                   String         @unique
  name                    String
  avatar                  String?
  role                    UserRole       @default(STUDENT)
  createdAt               DateTime       @default(now())
  updatedAt               DateTime       @updatedAt
  university              String?
  major                   String?
  year                    String?
  bio                     String?
  skills                  String[]
  rating                  Float          @default(0)
  reviewCount             Int            @default(0)
  location                String
  latitude                Float?
  longitude               Float?
  password                String?
  emailVerified           DateTime?
  verificationToken       String?
  verificationTokenExpiry DateTime?
  totpSecret              String?
  twoFactorEnabled        Boolean        @default(false)
  isSaaSAdmin             Boolean        @default(false)
  isSuspended             Boolean        @default(false)
  suspendedAt             DateTime?
  suspensionReason        String?
  receivedMessages        Message[]      @relation("MessageReceiver")
  sentMessages            Message[]      @relation("MessageSender")
  notifications           Notification[]
  payments                Payment[]      @relation("PaymentUser")
  receivedReviews         Review[]       @relation("ReviewReceiver")
  reviews                 Review[]       @relation("Reviewer")
  acceptedTasks           Task[]         @relation("TaskAccepter")
  postedTasks             Task[]         @relation("TaskPoster")
  accounts                Account[]
  sessions                Session[]
  blockedUsers            BlockedUser[]  @relation("BlockerUser")
  blockedByUsers          BlockedUser[]  @relation("BlockedUser")
  reportsCreated          Report[]       @relation("ReportCreator")
  reportsReceived         Report[]       @relation("ReportedUser")

  @@index([location])
  @@index([rating])
  @@index([createdAt])
  @@index([email])
  @@map("users")
}

model Task {
  id            String        @id @default(cuid())
  title         String
  description   String
  subject       String
  deadline      DateTime
  budget        Decimal       @db.Decimal(10, 2)
  status        TaskStatus    @default(OPEN)
  paymentStatus PaymentStatus @default(PENDING)
  mediaUrls     String[]      @default([])
  createdAt     DateTime      @default(now())
  updatedAt     DateTime      @updatedAt
  location      String
  latitude      Float?
  longitude     Float?
  posterId      String
  accepterId    String?
  messages      Message[]
  payments      Payment[]
  reviews       Review[]
  accepter      User?         @relation("TaskAccepter", fields: [accepterId], references: [id])
  poster        User          @relation("TaskPoster", fields: [posterId], references: [id])

  @@index([status])
  @@index([location])
  @@index([subject])
  @@index([createdAt])
  @@index([deadline])
  @@index([posterId])
  @@index([accepterId])
  @@index([budget])
  @@map("tasks")
}

model Review {
  id         String   @id @default(cuid())
  rating     Int
  comment    String?
  createdAt  DateTime @default(now())
  taskId     String
  reviewerId String
  receiverId String
  receiver   User     @relation("ReviewReceiver", fields: [receiverId], references: [id])
  reviewer   User     @relation("Reviewer", fields: [reviewerId], references: [id])
  task       Task     @relation(fields: [taskId], references: [id])

  @@unique([taskId, reviewerId])
  @@index([taskId])
  @@index([receiverId])
  @@index([createdAt])
  @@map("reviews")
}

model Message {
  id         String   @id @default(cuid())
  content    String
  type       String   @default("text")
  mediaUrl   String?
  createdAt  DateTime @default(now())
  taskId     String
  senderId   String
  receiverId String
  receiver   User     @relation("MessageReceiver", fields: [receiverId], references: [id])
  sender     User     @relation("MessageSender", fields: [senderId], references: [id])
  task       Task     @relation(fields: [taskId], references: [id])

  @@index([taskId])
  @@index([senderId])
  @@index([receiverId])
  @@index([createdAt])
  @@map("messages")
}

model Payment {
  id              String        @id @default(cuid())
  amount          Decimal       @db.Decimal(10, 2)
  status          PaymentStatus @default(PENDING)
  stripePaymentId String?       @unique
  createdAt       DateTime      @default(now())
  updatedAt       DateTime      @updatedAt
  taskId          String
  userId          String
  task            Task          @relation(fields: [taskId], references: [id])
  user            User          @relation("PaymentUser", fields: [userId], references: [id])

  @@index([status])
  @@index([taskId])
  @@index([userId])
  @@index([createdAt])
  @@index([stripePaymentId])
  @@map("payments")
}

model Notification {
  id        String    @id @default(cuid())
  userId    String
  type      String
  title     String
  body      String?
  link      String?
  readAt    DateTime?
  createdAt DateTime  @default(now())
  user      User      @relation(fields: [userId], references: [id])

  @@index([userId, readAt, createdAt])
  @@map("notifications")
}

model Waitlist {
  id       String   @id @default(cuid())
  email    String   @unique
  phone    String?  // Optional in DB but required by API validation
  name     String?
  city     String?
  college  String?
  joinedAt DateTime @default(now())
  status   String   @default("pending")

  @@map("waitlist")
}

/**
 * --- Add these models for NextAuth ---
 */
model Account {
  id                String  @id @default(cuid())
  userId            String
  type              String
  provider          String
  providerAccountId String
  refresh_token     String? @db.Text
  access_token      String? @db.Text
  expires_at        Int?
  token_type        String?
  scope             String?
  id_token          String? @db.Text
  session_state     String?
  user              User    @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([provider, providerAccountId])
}

model Session {
  id           String   @id @default(cuid())
  sessionToken String   @unique
  userId       String
  expires      DateTime
  user         User     @relation(fields: [userId], references: [id], onDelete: Cascade)
}

model BlockedUser {
  id        String   @id @default(cuid())
  blockerId String
  blockedId String
  reason    String?
  createdAt DateTime @default(now())
  blocker   User     @relation("BlockerUser", fields: [blockerId], references: [id], onDelete: Cascade)
  blocked   User     @relation("BlockedUser", fields: [blockedId], references: [id], onDelete: Cascade)

  @@unique([blockerId, blockedId])
  @@index([blockerId])
  @@index([blockedId])
  @@map("blocked_users")
}

model Report {
  id         String       @id @default(cuid())
  reporterId String
  reportedId String?
  taskId     String?
  type       ReportType
  category   String
  reason     String
  status     ReportStatus @default(PENDING)
  createdAt  DateTime     @default(now())
  updatedAt  DateTime     @updatedAt
  reviewedBy String?
  reviewedAt DateTime?
  action     String?
  notes      String?
  reporter   User         @relation("ReportCreator", fields: [reporterId], references: [id])
  reported   User?        @relation("ReportedUser", fields: [reportedId], references: [id])

  @@index([status])
  @@index([type])
  @@index([reporterId])
  @@index([reportedId])
  @@index([taskId])
  @@index([createdAt])
  @@map("reports")
}

enum UserRole {
  STUDENT
  ADMIN
}

enum TaskStatus {
  OPEN
  IN_PROGRESS
  COMPLETED
  CANCELLED
}

enum PaymentStatus {
  PENDING
  COMPLETED
  FAILED
  REFUNDED
}

enum ReportType {
  USER
  TASK
}

enum ReportStatus {
  PENDING
  REVIEWING
  RESOLVED
  DISMISSED
}
